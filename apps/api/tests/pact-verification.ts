#!/usr/bin/env node
import { Verifier } from '@pact-foundation/pact';
import path from 'node:path';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';

const execAsync = promisify(exec);

/**
 * Pact Provider Verification
 * Verifies that the API fulfills the contracts generated by consumers (MiniApp)
 */
async function verifyPactContracts() {
  console.log('üîê Starting Pact provider verification for LessonsAPI');
  
  // Start API server for testing
  console.log('üöÄ Starting API server...');
  const apiServer = exec('pnpm start:dev', { 
    cwd: path.resolve(process.cwd()),
    env: { ...process.env, NODE_ENV: 'test', PORT: '3001' }
  });

  // Wait for server to be ready
  await new Promise(resolve => setTimeout(resolve, 3000));

  try {
    const verifier = new Verifier({
      provider: 'LessonsAPI',
      providerBaseUrl: 'http://localhost:3001',
      
      // Pact files location - from MiniApp consumer
      pactUrls: [
        path.resolve(process.cwd(), '../miniapp/tests/contracts/pacts/miniapp-lessonsapi.json')
      ],
      
      // Provider states - data setup for tests
      stateHandlers: {
        'lesson swift-variables-constants exists': async () => {
          console.log('üìö Setting up provider state: lesson exists');
          // In real scenario, seed test database
          // For now, just ensure our mock data is available
          return Promise.resolve('State setup complete');
        }
      },
      
      // Request filters to modify requests before verification
      requestFilter: (req, res, next) => {
        // Add any required headers or authentication
        req.headers['x-telegram-init-data'] = 'mock-telegram-data';
        console.log('üîß Request filter applied:', req.method, req.path);
        next();
      },
      
      // Verification options
      publishVerificationResult: false, // Set true for CI/Pact Broker
      providerVersion: '1.0.0',
      providerVersionTags: ['master', 'production'],
      
      logLevel: 'INFO',
      timeout: 30000,
    });

    console.log('‚úÖ Running Pact verification...');
    await verifier.verifyProvider();
    
    console.log('üéâ All Pact contracts verified successfully!');
    
  } catch (error) {
    console.error('‚ùå Pact verification failed:', error.message);
    console.error(error.stack);
    process.exit(1);
  } finally {
    // Clean up API server
    console.log('üßπ Cleaning up API server...');
    apiServer.kill('SIGTERM');
  }
}

async function generateAndVerifyPacts() {
  console.log('üîÑ Full Pact workflow: Generate ‚Üí Verify');
  
  try {
    // Step 1: Generate consumer contracts (MiniApp)
    console.log('üìù Step 1: Generating consumer contracts...');
    const { stdout: consumerOutput } = await execAsync(
      'node tests/contracts/lesson-api.pact.spec.ts',
      { cwd: path.resolve(process.cwd(), '../miniapp') }
    );
    console.log(consumerOutput);
    
    // Step 2: Verify provider contracts (API)
    console.log('üîç Step 2: Verifying provider contracts...');
    await verifyPactContracts();
    
    console.log('‚úÖ Complete Pact workflow successful!');
    
  } catch (error) {
    console.error('‚ùå Pact workflow failed:', error.message);
    process.exit(1);
  }
}

// Run verification if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const command = process.argv[2];
  
  if (command === 'verify-only') {
    verifyPactContracts().catch(console.error);
  } else {
    generateAndVerifyPacts().catch(console.error);
  }
}